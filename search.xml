<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Webassembly-Rust]]></title>
    <url>%2F2019%2F06%2F10%2FWebassembly-Rust%2F</url>
    <content type="text"><![CDATA[上一篇文章有简单介绍Webassembly格式, 以及利用在线转化工具把C代码编辑到Webassembly. 这一篇文章我们继续探讨如何将Rust语言源代码编译到Webassembly并在谷歌浏览器中运行。Rust是火狐公司开发出来的一款静态编译型语言, Rust语言的详细介绍可以看官网. 之前例子在实际项目中的应用还要很多工作要做，比如如何在C中调用浏览器环境中的API，JS引擎的数据结构如何传递到C中等等，相较于之前介绍C语言编译到Webassembly并在浏览器运行的简单尝试，Rust社区一直积极的推动Webassembly于web端实际应用，并开发出一系列工具与类库。 安装 Rust 环境安装Rust前往 Install Rust 页面并跟随指示安装 Rust。这里会安装一个名为 “rustup” 的工具，这个工具能让你管理多个不同版本的 Rust。默认情况下，它会安装用于惯常Rust开发的 stable 版本 Rust Release。Rustup 会安装 Rust 的编译器 rustc、Rust 的包管理工具 cargo、Rust 的标准库 rust-std 以及一些有用的文档 rust-docs。 安装wasm-pack要将Rust模块构建为前端npm包，我们需要一个额外工具 wasm-pack。它会帮助我们把我们的代码编译成 WebAssembly 并制造出正确的 npm 包。使用下面的命令可以下载并安装它：1$ cargo install wasm-pack 构建我们的 WebAssembly npm 包创建一个新的 Rust 包。打开你用来存放你私人项目的目录，做这些事：12$ cargo new --lib wasm-test Created library `wasm-test` project 这里会在名为 wasm-test 的子目录里创建一个新的库，里面有下一步之前你所需要的一切：123+-- Cargo.toml+-- src +-- lib.rs 这里有一个 Cargo.toml 文件，这是我们配置构建的方式。如果你用过 npm 的 package.json，你应该会感到很熟悉。Cargo 的用法和它们类似。接下来，Cargo 在 src/lib.rs 生成了一些 Rust 代码： 来写点 Rust 代码在 src/lib.rs 写一些代码替换掉原来的：123456789101112131415161718192021extern crate wasm_bindgen; // 申明外部依赖库use wasm_bindgen::prelude::*; // 导入外部依赖库/* 在 #[] 中的内容叫做 "属性"，并以某种方式改变下面的语句。在这种情况下，下面的语句是一个 extern，它将告诉 Rust 我们想调用一些外部定义的函数。这个属性 wasm-bindgen 告诉我们如何找到这些函数 */#[wasm_bindgen]extern &#123; pub fn alert(s: &amp;str);&#125;/* 我们又看到了 #[wasm_bindgen] 属性。在这里，它并非定义一个 extern 块，而是 fn，这代表我们希望能够在 JavaScript 中使用这个 Rust 函数。 这和 extern 正相反：我们并非引入函数，而是要把函数给外部世界使用。 */#[wasm_bindgen]pub fn greet(name: &amp;str) &#123; alert(&amp;format!("Hello, &#123;&#125;!", name));&#125; 把我们的代码编译到 WebAssembly为了能够正确的编译我们的代码，首先我们需要配置 Cargo.toml。打开这个文件，将内容改为如下所示:12345678910111213[package]name = &quot;wasm-test&quot;version = &quot;0.1.0&quot;authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]description = &quot;A sample project with wasm-pack&quot;license = &quot;MIT/Apache-2.0&quot;repository = &quot;https://github.com/yourgithubusername/wasm-test&quot;[lib]crate-type = [&quot;cdylib&quot;][dependencies]wasm-bindgen = &quot;0.2&quot; 最重要的是添加底下的部分。第一个部分 — [lib] — 告诉 Rust 为我们的包建立一个 cdylib[dependencies] 部分。在这里我们告诉 Cargo 我们需要依赖哪个版本的 wasm-bindgen 构建NPM包Rust源代码完成，依赖配置也设置好了，准备构建NPM前端模块！1$ wasm-pack build wasm-pack build 会进行如下几个步骤： 把Rust代码编译为 WebAssembly. 在生成的 WebAssembly文件执行 wasm-bindgen , 生成一个npm能识别JS模块，这个模块包含刚生成WebAssembly文件. 生成一个 pkg 文件夹，并把生成的JS模块与WebAssembly文件移入. 读取 Cargo.toml 并生成对应的 package.json. 拷贝 README.md（如果有的话）到 pkg文件夹. 在网站上使用刚生成的包新建一个前端文件夹site，并运行：1$ npm init -y 编译package.json12345678910&#123; "scripts": &#123; "serve": "webpack-dev-server" &#125;, "devDependencies": &#123; "webpack": "^4.25.1", "webpack-cli": "^3.1.2", "webpack-dev-server": "^3.1.10" &#125;&#125; 新建一个webpack.config.js文件，内容如下：123456789const path = require('path');module.exports = &#123; entry: "./index.js", output: &#123; path: path.resolve(__dirname, "dist"), filename: "index.js", &#125;, mode: "development"&#125;; 新建一个index.html文件，内容如下：12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello-wasm example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="./index.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 新建一个index.js文件，内容如下：1234const js = import("./pkg/wasm-test.js");js.then(js =&gt; &#123; js.greet("WebAssembly");&#125;); 打开控制台，运行：12$ npm install$ npm run serve 打开谷歌浏览器，访问http://localhost:8080 应该会看到一个alert弹窗。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>webassembly, rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webassembly-Introduce]]></title>
    <url>%2F2019%2F05%2F26%2FWebassembly-Introduce%2F</url>
    <content type="text"><![CDATA[我们知道 JavaScript 是一门脚本语言，具有动态类型和灵活的表达力，我们知道脚本语言通常要解释运行，这也将要消耗一些性能开销，于是 Google 在 2009 年在 V8 中引入了 JIT(Just in time compiling) 技术，把 JavaScript 运行时的性能推到了顶峰，同年利用 V8 引擎诞生了 Node.js，打开了使用 JavaScript 写后端应用的大门。对于目前写网络应用而言 JavaScript 已经足够用了，加上 Google V8 引擎能帮我们解决掉大部分问题。但是当我们把 JavaScript 应用到诸如 3D 游戏、虚拟现实、增强现实、计算机视觉、图像/视频编辑以及大量的要求原生性能的其他领域的时候，就遇到了性能问题，尤其是移动平台进一步放大了这些性能瓶颈。 而 WebAssembly 的出现就是为了解决这个问题，它是一门低级的类汇编语言，可以运行在现代网络浏览器中的新型代码并且提供新的性能特性和效果。它设计的目的不是为了手写代码，而是为了诸如 C、C++ 和 Rust 等低级源语言提供一个高效的编译目标以便它们能够在网络上运行。对于网络平台而言，这具有巨大的意义——这为客户端 app 提供了一种在网络平台以接近本地速度的方式运行多种语言编写代码的方式；在这之前，客户端 app 是不可能做到的。 文件格式与生成WebAssembly 有二进制 (.wasm) 和文本 (.wast) 两种格式，并且两种格式可以互享转换，在传输和运行时使用二进制格式，而文本格式是为了阅读和开发调试所使用。 以 C 为例，首先把 C 程序编译为 WebAssembly 格式，本地编译可以查看 编译 C/C++ 为 WebAssembly 文章进行相关软件的安装，为了方便可以直接使用这款在线工具进行转换 WasmFiddle 我们先来个简单的，在 main 中返回一个数字，在 add 方法中求和:1234567int main() &#123; return 42;&#125;int add(int a, int b) &#123; return a + b;&#125; 转换过后的 .wast 文本格式为，我们可以从这个文本看出分别 export 了 main 与 add 方法12345678910111213141516(module (table 0 anyfunc) (memory $0 1) (export "memory" (memory $0)) (export "main" (func $main)) (export "add" (func $add)) (func $main (; 0 ;) (result i32) (i32.const 42) ) (func $add (; 1 ;) (param $0 i32) (param $1 i32) (result i32) (i32.add (get_local $1) (get_local $0) ) )) 导入并初始化使用 Fetch 获取模块并初始化调用:12345678fetch('module.wasm') .then(response =&gt; response.arrayBuffer()) .then(bytes =&gt; WebAssembly.instantiate(bytes)) .then(results =&gt; &#123; console.log(typeof results.instance.exports.main); // function console.log(results.instance.exports.main()); // 42 console.log(results.instance.exports.add(1, 2)); // 3 &#125;) 使用 XMLHttpRequest 获取模块并初始化调用:123456789101112131415const request = new XMLHttpRequest();request.open('GET', 'module.wasm');request.responseType = 'arraybuffer';request.onload = function() &#123; var bytes = request.response; WebAssembly .instantiate(bytes) .then(results =&gt; &#123; console.log(typeof results.instance.exports.main); console.log(results.instance.exports.main()); console.log(results.instance.exports.add(1, 2)); &#125;);&#125;;request.send(); 可以畅想下以后 WebAssembly 普及的话，到时我们用的 React、Vue、Angular 可能就是用 C/C++ 或者其他底层语言写的。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>webassembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-Event-Loop]]></title>
    <url>%2F2019%2F05%2F26%2FJS-Event-Loop%2F</url>
    <content type="text"><![CDATA[事件循环的顺序，决定了 JavaScript 代码的执行顺序。它从 script (整体代码) 开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的 Micro Task。当所有可执行的 Micro Task 执行完毕之后。循环再次从 Macro Task 开始，找到其中一个任务队列执行完毕，然后再执行所有的 Micro Task，在执行 Micro Task、Macro Task 的时候同样遵循 Event Loop 原则，就这样一直循环下去。 在讨论 Micro Task、Macro Task 之前我们先来看一个例子，分析以下代码并思考 log 打的印顺序 示例代码 123456789101112131415console.log('script start');setTimeout(() =&gt; &#123; console.log('setTimeout 1');&#125;);Promise.resolve().then(() =&gt; &#123; console.log('promise 1');&#125;).then(() =&gt; &#123; console.log('promise 2');&#125;);console.log('script end'); 运行结果为： 12345script startscript endpromise 1promise 2setTimeout 1 先明白几个概念 Event LoopEvent Loop：事件循环 我们知道 JavaScript 是单线程语言，一心不能二用，也就是说它只能把一件事干完才能去干另一件事，但前端的一些任务是非常耗时的，比如网络请求，定时器和事件监听，如果让它们和别的任务一样，都老老实实的排队等待执行的话，执行效率会非常的低，甚至导致页面的假死。所以为了保证使用流畅，浏览器采用了 Event Loop 事件循环系统来管理，把那些耗时的任务放入 task queues 栈中，等主程序执行完再执行 task queues 中的任务，通常使用回调函数监听 task queues 中的任务状态。 在其它语言中可以迟延执行，比如 C 语言的 sleep(3) 可以迟延 3 秒执行后边的逻辑，但是在 JavaScript 中是没有这样的操作（除了 alert、confrim、prompt 和异步 xhr，官方说这些是历史遗留的错误设计😂），只能使用异步方式去模拟，模拟的实际也不是真正意义上的 sleep 效果。 Micro Task、Macro Task想要搞明白这个问题，首先要了解 Event Loop 下的 Micro Task 和 Macro Task，在运行主程序时会把异步逻辑根据情况推到 Micro Task 或者 Macro Task 栈中，具体规则如下 以下情况会推到 Micro Task 栈中 cess.nextTick mise ect.observe ationObserver 下情况会推到 Macro Task 栈中 setTimeout setInterval setImmediate I/O UI render 然后再来看实例代码的实际执行逻辑 执行 console.log(‘script start’) 直接输出 执行 setTimeout 把回调函数放入 Macro Task 栈中 执行 Promise 把两个 then 的回调函数放入 Micro Task 栈中 执行 console.log(‘script end’) 直接输出 执行 Micro Task 中所有任务 i. 执行 console.log(‘promise 1’) 直接输出 ii. 执行 console.log(‘promise 2’) 直接输出 执行 Macro Task 中所有任务 执行 console.log(‘setTimeout 1’) 直接输出]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
