<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Webassembly-Introduce]]></title>
    <url>%2F2019%2F05%2F26%2FWebassembly-Introduce%2F</url>
    <content type="text"><![CDATA[我们知道 JavaScript 是一门脚本语言，具有动态类型和灵活的表达力，我们知道脚本语言通常要解释运行，这也将要消耗一些性能开销，于是 Google 在 2009 年在 V8 中引入了 JIT(Just in time compiling) 技术，把 JavaScript 运行时的性能推到了顶峰，同年利用 V8 引擎诞生了 Node.js，打开了使用 JavaScript 写后端应用的大门。对于目前写网络应用而言 JavaScript 已经足够用了，加上 Google V8 引擎能帮我们解决掉大部分问题。但是当我们把 JavaScript 应用到诸如 3D 游戏、虚拟现实、增强现实、计算机视觉、图像/视频编辑以及大量的要求原生性能的其他领域的时候，就遇到了性能问题，尤其是移动平台进一步放大了这些性能瓶颈。 而 WebAssembly 的出现就是为了解决这个问题，它是一门低级的类汇编语言，可以运行在现代网络浏览器中的新型代码并且提供新的性能特性和效果。它设计的目的不是为了手写代码，而是为了诸如 C、C++ 和 Rust 等低级源语言提供一个高效的编译目标以便它们能够在网络上运行。对于网络平台而言，这具有巨大的意义——这为客户端 app 提供了一种在网络平台以接近本地速度的方式运行多种语言编写代码的方式；在这之前，客户端 app 是不可能做到的。 文件格式与生成WebAssembly 有二进制 (.wasm) 和文本 (.wast) 两种格式，并且两种格式可以互享转换，在传输和运行时使用二进制格式，而文本格式是为了阅读和开发调试所使用。 以 C 为例，首先把 C 程序编译为 WebAssembly 格式，本地编译可以查看 编译 C/C++ 为 WebAssembly 文章进行相关软件的安装，为了方便可以直接使用这款在线工具进行转换 WasmFiddle 我们先来个简单的，在 main 中返回一个数字，在 add 方法中求和:1234567int main() &#123; return 42;&#125;int add(int a, int b) &#123; return a + b;&#125; 转换过后的 .wast 文本格式为，我们可以从这个文本看出分别 export 了 main 与 add 方法12345678910111213141516(module (table 0 anyfunc) (memory $0 1) (export "memory" (memory $0)) (export "main" (func $main)) (export "add" (func $add)) (func $main (; 0 ;) (result i32) (i32.const 42) ) (func $add (; 1 ;) (param $0 i32) (param $1 i32) (result i32) (i32.add (get_local $1) (get_local $0) ) )) 导入并初始化使用 Fetch 获取模块并初始化调用:12345678fetch('module.wasm') .then(response =&gt; response.arrayBuffer()) .then(bytes =&gt; WebAssembly.instantiate(bytes)) .then(results =&gt; &#123; console.log(typeof results.instance.exports.main); // function console.log(results.instance.exports.main()); // 42 console.log(results.instance.exports.add(1, 2)); // 3 &#125;) 使用 XMLHttpRequest 获取模块并初始化调用:123456789101112131415const request = new XMLHttpRequest();request.open('GET', 'module.wasm');request.responseType = 'arraybuffer';request.onload = function() &#123; var bytes = request.response; WebAssembly .instantiate(bytes) .then(results =&gt; &#123; console.log(typeof results.instance.exports.main); console.log(results.instance.exports.main()); console.log(results.instance.exports.add(1, 2)); &#125;);&#125;;request.send(); 可以畅想下以后 WebAssembly 普及的话，到时我们用的 React、Vue、Angular 可能就是用 C/C++ 或者其他底层语言写的。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>webassembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-Event-Loop]]></title>
    <url>%2F2019%2F05%2F26%2FJS-Event-Loop%2F</url>
    <content type="text"><![CDATA[事件循环的顺序，决定了 JavaScript 代码的执行顺序。它从 script (整体代码) 开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的 Micro Task。当所有可执行的 Micro Task 执行完毕之后。循环再次从 Macro Task 开始，找到其中一个任务队列执行完毕，然后再执行所有的 Micro Task，在执行 Micro Task、Macro Task 的时候同样遵循 Event Loop 原则，就这样一直循环下去。 在讨论 Micro Task、Macro Task 之前我们先来看一个例子，分析以下代码并思考 log 打的印顺序 示例代码 123456789101112131415console.log('script start');setTimeout(() =&gt; &#123; console.log('setTimeout 1');&#125;);Promise.resolve().then(() =&gt; &#123; console.log('promise 1');&#125;).then(() =&gt; &#123; console.log('promise 2');&#125;);console.log('script end'); 运行结果为： 12345script startscript endpromise 1promise 2setTimeout 1 先明白几个概念 Event LoopEvent Loop：事件循环 我们知道 JavaScript 是单线程语言，一心不能二用，也就是说它只能把一件事干完才能去干另一件事，但前端的一些任务是非常耗时的，比如网络请求，定时器和事件监听，如果让它们和别的任务一样，都老老实实的排队等待执行的话，执行效率会非常的低，甚至导致页面的假死。所以为了保证使用流畅，浏览器采用了 Event Loop 事件循环系统来管理，把那些耗时的任务放入 task queues 栈中，等主程序执行完再执行 task queues 中的任务，通常使用回调函数监听 task queues 中的任务状态。 在其它语言中可以迟延执行，比如 C 语言的 sleep(3) 可以迟延 3 秒执行后边的逻辑，但是在 JavaScript 中是没有这样的操作（除了 alert、confrim、prompt 和异步 xhr，官方说这些是历史遗留的错误设计😂），只能使用异步方式去模拟，模拟的实际也不是真正意义上的 sleep 效果。 Micro Task、Macro Task想要搞明白这个问题，首先要了解 Event Loop 下的 Micro Task 和 Macro Task，在运行主程序时会把异步逻辑根据情况推到 Micro Task 或者 Macro Task 栈中，具体规则如下 以下情况会推到 Micro Task 栈中 cess.nextTick mise ect.observe ationObserver 下情况会推到 Macro Task 栈中 setTimeout setInterval setImmediate I/O UI render 然后再来看实例代码的实际执行逻辑 执行 console.log(‘script start’) 直接输出 执行 setTimeout 把回调函数放入 Macro Task 栈中 执行 Promise 把两个 then 的回调函数放入 Micro Task 栈中 执行 console.log(‘script end’) 直接输出 执行 Micro Task 中所有任务 i. 执行 console.log(‘promise 1’) 直接输出 ii. 执行 console.log(‘promise 2’) 直接输出 执行 Macro Task 中所有任务 执行 console.log(‘setTimeout 1’) 直接输出]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
